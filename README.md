# JS-Core-Advanced
# TASKS
### [1] use strict 
Напишите функцию для расчета факториала 
числа. Функция должна принимать число в 
качестве аргумента и возвращать его 
факториал. Учтите использование строгого 
режима.
### [2] Variables var, let, const
Создайте блок кода внутри функции и 
объявите переменную с именем x с 
использованием var, let и const. Попытайтесь 
обратиться к этой переменной как внутри, так 
и вне блока. Какие переменные видны 
снаружи блока, а какие нет?
### [3] Data types
Напишите функцию для сравнения двух 
объектов, чтобы определить, содержит ли 
первый из них эквивалентные значения 
свойств по сравнению со вторым.
### [4] Arrays
Напишите функцию, которая принимает 
массив с числами и увеличивает каждое 
число из массива на 10 процентов.
### [5] Functions
Напишите функцию, которая многократно 
выполняет заданную операцию через 
фиксированный интервал, используя 
setInterval().
### [6] Classes
Создайте класс под названием «Человек» со 
свойствами имени, возраста и страны. 
Включите метод для отображения сведений о 
человеке. Создайте два экземпляра класса 
«Человек» и отобразите их сведения.
### [7] Error Handling
Напишите функцию, которая принимает 
число в качестве параметра и выдает 
пользовательскую ошибку, если число не 
является целым числом.
### [8] Promise
Напишите функцию, выполняющую серию 
асинхронных операций последовательно, 
используя Promises.
### [9] Async/Await
Напишите функцию, которая использует 
async/await для загрузки данных с удаленного 
сервера (например, с помощью API) и 
возвращает полученный результат.
### [10] Event Loop
Напишите функцию, которая принимает 
callback функцию и вызывает ее после 
задержки в 2 секунды.

***
# THEORY

## [1] Use strict

> **'use strict'** включает строгий режим выполнения JavaScript. 
Эта строка должна располагаться в самом начале скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на действия, которые ранее пропускал. Если строгий режим был включён, то отключить его для файла уже нельзя. 

```js
'use strict' // Располагаем строку в самом начале файла!

const name = 'Alex'

// ... другой код
```

Строгий режим делает следующее:
- Выбрасывает ошибки, когда в коде используются некоторые небезопасные конструкции.
- Выключает функции языка, которые запутывают код и потому не должны использоваться. 
- Предотвращает использование слов, которые могут быть использованы в качестве ключевых в будущем. 

Ограничения:
- Нельзя использовать переменные без объявления
- Параметры функции не могут иметь одинаковые имена 
- Другое поведение this 
- Запрещено использовать зарезервированные слова
- Ограничение небезопасных конструкций 

*Подробнее:* [use strict](https://doka.guide/js/use-strict/)


## [2] Variables var, let, const

> **Переменные** — это именованные контейнеры для хранения данных.

Для создания переменной используется ключевое слово **let**, **const** или **var**. Сразу за ключевым словом идёт название переменной либо перечень переменных через запятую. Создание переменной также называют объявлением переменной.

```js
var singleVariable

let firstVariable, secondVariable, thirdVariable
```
**Для имени переменной можно использовать следующие символы:**
- буквы латинского алфавита;
- цифры;
- символы $ и _.

### Объявление

Используя ключевое слово let, можно объявить переменную без присвоения ей начального значения. В таком случае она будет равна undefined:

```js
let a
console.log(a)
// undefined

a = 5
console.log(a)
// 5
```

При помощи const нельзя объявлять переменные без значения:

```js
const a
// SyntaxError: Missing initializer in const declaration

// Правильно
const b = 5
```

### Переменные var

Переменные var можно объявлять без присвоения им значения, в таком случае они будут равны undefined:

```js
var a
console.log(a)
// undefined

var b = 5
console.log(b)
// 5
```

Переменные, объявленные через var, имеют функциональную область видимости. Они доступны только в пределах текущей функции или глобального объекта, если функции нет:

```js
if (true) {
  var a = 5
}

function foo() {
  var b = 10
}

console.log(a)
// 5
console.log(b)
// ReferenceError: b is not defined
```
Объявление переменных вне функций делает их глобальными переменными. Они доступны как свойства глобального объекта:

```js
var varVariable = 5

console.log(window.varVariable)
// 5
```

*Подробнее:* [Variables var, let, const](https://doka.guide/js/var-let/)

### Hoisting

К переменным, объявленным при помощи ключевого слова var, можно обращаться до момента объявления. В отличие от let и const, ошибки это не вызовет. Такое поведение называется hoisting - «всплытие»:

```js
console.log(a)
// undefined

var a = 5

console.log(a)
// 5
```
*Подробнее:* [Hoisting](https://www.dev-notes.ru/articles/what-is-hoisting-in-javascript/)




## [3] Data Types

Стандарт ECMAScript определяет 8 типов.

Из них примитивные:
- Undefined (Неопределённый тип) : `typeof instance === "undefined"`
- Boolean (Булев, Логический тип) : `typeof instance === "boolean"`
- Number (Число) : `typeof instance === "number"`
- String (Строка) : `typeof instance === "string"`
- BigInt : `typeof instance === "bigint"`
- Symbol (en-US) (в ECMAScript 6) : `typeof instance === "symbol"`
- Null (Null тип ) : `typeof instance === "object"`. Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;

Ссылочный:
- Object (Объект) : `typeof instance === "object"`. Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date и множество других структур;


### Undefined
> **Undefined** — это тип, состоящий из одного значения undefined. Оно используется, чтобы обозначить, что переменной не присвоено значение.

Если переменная инициализирована с помощью let или var и ей не присвоено значение, то JavaScript автоматически устанавливает значение undefined.

```js
let name

console.log(name)
// undefined
```
*Подробнее:* [Undefined](https://doka.guide/js/undefined/)


### Boolean
> Логический или булев тип boolean может принимать лишь истинное **(true)** и ложное **(false)** значения.

Создать булево значение можно несколькими способами.
Первый — явно указать значение, используя ключевые слова true и false:

```js
const truthyValue = true // «Истина»
const falsyValue = false // «Ложь»
```

Второй способ — использовать метод Boolean:

```js
const truthyValue = Boolean(1) // «Истина»
const falsyValue = Boolean('') // «Ложь»
```
*Подробнее:* [Boolean](https://doka.guide/js/boolean/)

### Number

Тип данных «число» (number) содержит числа с плавающей точкой в диапазоне от -(253 − 1) до 253 − 1, а также специальные значения Infinity, -Infinity и NaN.

Для этого типа данных определены стандартные арифметические операции сложения +, вычитания -, умножения *, деления /, взятия остатка от целочисленного деления %, сравнения >, <, >=, <=, ==, ===, !=, !==.

Для записи чисел используются цифры, для разделения целой и десятичной части используется точка:

```js
const int = 4
const decimal = 0.101
const sameDecimal = .101
```
Числа так же могут быть представлены в двоичном, восьмеричном или шестнадцатеричном виде. Такие числа начинаются с приставки 0b, 0o, 0x соответственно. При выводе на экран они будут преобразованы в десятичную систему счисления:

```js
const binary = 0b11
console.log(binary)
// 3

const octal = 0o77
console.log(octal)
// 63

const hexadecimal = 0xFF
console.log(hexadecimal)
// 255
```
*Подробнее:* [Number](https://doka.guide/js/number/)

### String

> Любые текстовые данные в JavaScript — это строки (англ. string). Строки представляют собой последовательность символов. Созданная строка является иммутабельной (immutable) и не может быть изменена.

Есть несколько способов создать строку:

- одинарными кавычками ';
- двойными кавычками ";
- шаблонной строкой через обратный апостроф `.

Записи одинарными и двойными кавычками идентичны:

```js
const double = "Добрый день!"
const single = 'Добрый день'
```

Можно создать пустую строку или строку из пробелов:

```js
const empty = ''
const spaces = '   '
```

Если в записи одинарными кавычками нужно поставить апостроф, то символ экранируют обратным слэшем \. Так мы даём JavaScript понять, что это просто символ, а не закрывающая кавычка:

```js
const who = 'I\'m a good person.'
```

Шаблонные строки позволяют подставлять в строку значения переменных. Между обратными апострофами пишется текст, а в местах, где нужно вставить значение из переменной используется синтаксис ${имя_переменной}:

```js
const product = 'Томаты'
const quantity = 1

console.log(`Список покупок: ${product}, ${quantity}шт.`)
// Список покупок: Томаты, 1шт.
```
*Подробнее:* [String](https://doka.guide/js/string/)

### BigInt

> **BigInt** — примитивный тип, который представляет целые числа больше 253-1. Эти числа уже не помещаются в стандартный примитив «число». Этот тип может использоваться для работы с произвольно большими целыми числами.

Создать BigInt можно двумя способами.

-  Добавить суффикс n в конец записи числа:

```js
const biggy = 9997000254740991n
```


- Вызвать конструктор BigInt:

```js
const alsoBig = BigInt(9997000254999999)
```

Для BigInt определены операции сложения +, вычитания -, умножения *, взятия остатка от деления %, возведение в степень **. Операция деления / также работает, но дробная часть будет отброшена:

```js
const seven = 7n
const five = 5n

console.log(seven / five)
// 1
```
*Подробнее:* [BigInt](https://doka.guide/js/bigint/)

### Symbol

> **Symbol** - примитивный тип, значения которого создаются с помощью вызова функции Symbol. Каждый созданный символ уникален.

Символы могут использоваться в качестве имён свойств в объектах. Символьные свойства могут быть прочитаны только при прямом обращении и не видны при обычных операциях.

Для создания символа нужно вызвать функцию Symbol:

```js
const sym = Symbol()
const symTwo = Symbol()

console.log(sym === symTwo)
// false
```
*Подробнее:* [Symbol](https://doka.guide/js/symbol/)

### Null

> **Null** - это тип, единственным значением которого является значение null.

Значение null используют, когда нужно обозначить намеренное отсутствие значения объекта (объект с неопределённой структурой).

В языке существует похожее примитивное значение undefined. Оно обозначает, что переменной ещё не присвоено значение. Их можно легко спутать, потому что оба обозначают отсутствие значения. Разница состоит в том, что null обозначает намеренное отсутствие значения объекта (объект без заданной структуры), а undefined — что переменной (не объекту) ещё не присвоено значение.

*Подробнее:* [Null](https://doka.guide/js/null-primitive/)

### Object

> **Объекты** – это ассоциативные массивы с рядом дополнительных возможностей.

Они хранят свойства (пары ключ-значение), где:

- ключи свойств должны быть строками или символами (обычно строками).
- значения могут быть любого типа.

Чаще всего объекты создают с помощью литеральной записи:

```js
const cat = {}
```

Или с помощью конструктора Object:

```js
const book = new Object({ title: 'Война и мир', author: 'Лев Толстой' })
```


Чтобы получить доступ к свойству, мы можем использовать:

Запись через точку: `obj.property`.
Квадратные скобки `obj["property"]`. Квадратные скобки позволяют взять ключ из переменной, например, `obj[varWithKey]`.

Дополнительные операторы:

- Удаление свойства: `delete obj.prop`.
- Проверка существования свойства: `"key" in obj`.
- Перебор свойств объекта: цикл `for for (let key in obj)`.

*Подробнее:* [Object](https://learn.javascript.ru/object-basics)


## [4] Arrays

> **Массив** – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

*Объявление*

```js
// квадратные скобки (обычно)
let arr = [item1, item2...];

// new Array (очень редко)
let arr = new Array(item1, item2...);
```

Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

- Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
- Если мы уменьшаем length вручную, массив укорачивается.

*Получение элементов:*
- Мы можем получить элемент по его индексу, например `arr[0]`.
- Также мы можем использовать метод `at(i)` для получения элементов с отрицательным индексом, для отрицательных значений `i`, он отступает от конца массива. В остальном он работает так же, как `arr[i]`, если `i >= 0`.

Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

-`push(...items)` добавляет items в конец массива.
- `pop()` удаляет элемент в конце массива и возвращает его.
- `shift()` удаляет элемент в начале массива и возвращает его.
- `unshift(...items)` добавляет items в начало массива.

Чтобы пройтись по элементам массива:
- `for (let i=0; i<arr.length; i++)` – работает быстрее всего, совместим со старыми браузерами.
- `for (let item of arr)` – современный синтаксис только для значений элементов (к индексам нет доступа).

*Подробнее:* [Arrays](https://learn.javascript.ru/array)



## [5] Functions

В JavaScript функции являются фундаментальным строительным блоком, позволяющим организовывать и структурировать код для выполнения определенных задач.

### Function Declaration

```js
function greet(name) {
  return "Привет, " + name + "!";
}
```
*Подробнее:* [Function Declaration](https://learn.javascript.ru/function-basics)

Функции, объявленные таким способом, могут быть вызваны до того, как код, содержащий их, выполнится.

### Function Expression

```js
const greet = function (name) {
  return "Привет, " + name + "!";
};
```

В этом случае, функция присваивается переменной. Такие функции могут быть вызваны только после того, как они были определены.

*Подробнее:* [Function Expression](https://learn.javascript.ru/function-expressions)

### Стрелочная функция

```js
const greet = (name) => {
  return "Привет, " + name + "!";
};
```

Стрелочные функции представляют сокращенный синтаксис для функциональных выражений и предоставляют более лаконичный способ определения функций.

*Подробнее:* [Стрелочная функция](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

### IIFE (Immediately Invoked Function Expression)

```js
(function () {
  // код
})();
```

Это функциональное выражение, которое вызывается сразу после объявления. Оно помогает изолировать переменные и функции от глобальной области видимости.

*Подробнее:* [IIFE](https://developer.mozilla.org/ru/docs/Glossary/IIFE)

### Генераторы

```js
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generateSequence();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

Генераторы представляют специальный тип функций, который может приостанавливать и возобновлять свое выполнение. Они возвращают объект-итератор, который позволяет пошагово получать значения.

*Подробнее:* [Генераторы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Generator)


### Продвинутая работа с функциями
> **Рекурсия** – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

> **Замыкание** -  это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем.

*Подробнее:* [Продвинутая работа с функциями](https://learn.javascript.ru/advanced-functions)



## [6] Classes

> **Классы** в JavaScript представляют собой специальный тип объекта, который позволяет создавать объекты с определенными свойствами и методами. Они используются для организации кода в более понятном и модульном стиле, особенно в объектно-ориентированном программировании (ООП). Введение классов в стандарте ECMAScript 2015 (ES6) значительно упростило и стандартизировало работу с объектами и наследованием в JavaScript.

### Определение класса

**Класс** определяется с использованием ключевого слова class, за которым следует имя класса и тело класса с его свойствами и методами.

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return `Привет, меня зовут ${this.name} и мне ${this.age} лет.`;
  }
}
```

### Создание экземпляров класса

После определения класса можно создать его экземпляр с помощью оператора new.

```js
const person1 = new Person("Иван", 20);
console.log(person1.greet()); // Вывод: Привет, меня зовут Иван и мне 20 лет.
```

### Конструктор

**Конструктор** - это метод, который вызывается при создании нового экземпляра класса. В нем обычно устанавливаются начальные значения свойств объекта.

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
```

### Методы класса

**Методы класса** - это функции, которые определены внутри тела класса и предназначены для выполнения определенных действий с объектом.

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return `Привет, меня зовут ${this.name} и мне ${this.age} лет.`;
  }
}
```

### Наследование

```js
class Student extends Person {
  constructor(name, age, grade) {
    super(name, age);
    this.grade = grade;
  }

  study() {
    return `${this.name} учится в ${this.grade} классе.`;
  }
}
```
В примере выше класс Student наследует свойства и методы класса Person.

### Свойства и методы класса

Свойства и методы класса могут быть **публичными (public)**, **приватными (private)** или **защищенными (protected)**. В JavaScript до версии ES6 не было официальной поддержки приватных свойств и методов. Однако с ES6 в классах JavaScript появилась поддержка приватных членов класса с использованием символа # перед именем свойства или метода.

```js
class MyClass {
  #privateProperty = 10; // Приватное свойство

  constructor() {
    this.publicProperty = 20; // Публичное свойство
  }

  #privateMethod() {
    // Приватный метод
    return this.#privateProperty + this.publicProperty;
  }

  publicMethod() {
    // Публичный метод
    return this.#privateMethod();
  }
}
```

### Статические методы

Статические методы принадлежат самому классу, а не его экземплярам, и вызываются через сам класс, а не через его экземпляры.

```js
class MathHelper {
  static add(a, b) {
    return a + b;
  }
}

console.log(MathHelper.add(5, 3)); // Вывод: 8
```
*Подробнее:* [Classes](https://learn.javascript.ru/classes)


## [7] Error Handling

### Использование блока try-catch

Это основной механизм обработки исключений в JavaScript. Код, который может вызвать ошибку, помещается в блок **try**, а обработчик ошибок помещается в блок **catch**. Если происходит ошибка в блоке **try**, исполнение переходит к соответствующему блоку **catch**.

### Блок finally

Вы можете использовать блок **finally** вместе с блоком **try-catch** для выполнения кода, который должен быть выполнен независимо от того, произошла ли ошибка или нет.

### Генерация собственных ошибок

Иногда полезно явно создавать ошибки в своем коде, чтобы указать на определенные ситуации.

```js
throw new Error("Сообщение об ошибке");
```
*Подробнее:* [Error Handling](https://learn.javascript.ru/error-handling)


## [8] Promise
> **Promise** - специальный объект JavaScript, который используется для написания и обработки асинхронного кода.

Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса хранится результат вычисления, которое может быть уже выполнено или выполнится в будущем.

Промис может находиться в одном из трёх состояний:

- **pending** — стартовое состояние, операция стартовала;
- **fulfilled** — получен результат;
- **rejected** — ошибка.

```js
const promise = new Promise(function (resolve, reject) {
  const data = getData() // делаем асинхронную операцию: запрос в БД, API, etc.
  resolve(data) // переводим промис в состояние fulfilled. Результатом выполнения будет объект data
})

const errorPromise = new Promise(function (resolve, reject) {
  reject(new Error('ошибка')) // переводим промис в состояние rejected. Результатом выполнения будет объект Error
})
```

- первый параметр (в примере кода назван resolve) — колбэк для перевода промиса в состояние fulfilled, при его вызове аргументом передаётся результат операции;
- второй параметр (в примере кода назван reject) — колбэк для перевода промиса в состояние rejected, при его вызове аргументом передаётся информация об ошибке.


### Методы

Существует три метода, которые позволяют работать с результатом выполнения вычисления внутри промиса:

- **then()** - используют, чтобы выполнить код после успешного выполнения асинхронной операции.
- **catch()** - используют, чтобы выполнить код в случае ошибки при выполнении асинхронной операции.
- **finally()** - используют, чтобы выполнить код при завершении асинхронной операции. Он будет выполнен вне зависимости от того, была ли операция успешной или завершилась ошибкой.

*Подробнее:* [Promise](https://learn.javascript.ru/async)

### Promise API

В классе Promise есть 6 статических методов:

`Promise.all(promises)` – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.

`Promise.allSettled(promises)` (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
status: 
- `"fulfilled"`, если выполнен успешно или `"rejected"`, если ошибка,
- `value` – результат, если успешно или `reason` – ошибка, если нет.

`Promise.race(promises)` – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.

`Promise.any(promises)` (добавлен недавно) – ожидает первый успешно выполненный промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, `AggregateError` становится ошибкой `Promise.any`.

`Promise.resolve(value)` – возвращает успешно выполнившийся промис с результатом `value`.

`Promise.reject(error)` – возвращает промис с ошибкой `error`.


*Подробнее:* [Promise API](https://learn.javascript.ru/promise-api)


## [9] Async/await

Ключевое слово `async` перед объявлением функции:

Обязывает её всегда возвращать промис.
Позволяет использовать `await` в теле этой функции.
Ключевое слово `await` перед промисом заставит JavaScript дождаться его выполнения, после чего:

1. Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось `throw`.
2. Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.

Хотя при работе с `async/await` можно обходиться без `promise.then/catch`, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также `await` отлично работает в сочетании с `Promise.all`, если необходимо выполнить несколько задач параллельно.

*Подробнее:* [Async/await](https://learn.javascript.ru/async-await)

## [10] Event Loop

> **Event Loop** является стеком, где хранятся все задачи, которые не вошли в синхронный поток выполнения. После завершения синхронного потока - задачи начинают выполняться из Event Loop'а. Однако у Event Loop'а тоже есть свои правила. 

Он делит все задачи на подтипы:

- **микрозадачи**;

- **макрозадачи**;

- **задачи отрисовки**.

В **микрозадачи** попадают в основном только две категории: then у промисов, а также Intersection Observer.

**Макрозадачами** являются все асинхронные операции, такие как XmlHTTPRequest, setTimeout и так далее.

В **задачи отрисовки** попадают задачи связанные с отрисовкой и обновлением контента страницы.


*Каким образом определяется, какая из задач выполняется первой?*

1. Сначала Event Loop проверяет выполнились ли все синхронные задачи

2. Потом выполняются **все задачи** из микротасков

3. После выполнения всех микротасков - очередь очищается

4. Затем мы берем **одну макрозадачу** из списка и выполняем ее

5. После выполнения мы смотрим нужно ли нам сделать перерисовку страницы

6. Если перерисовать страницу нужно - делаем это

7. Все снова начинается с первого пункта 

*Подробнее:* [Event Loop](https://habr.com/ru/articles/762618/)